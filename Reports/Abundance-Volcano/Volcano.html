<!DOCTYPE html>
<meta charset="utf-8">

<!-- TODO: Move css into its own file -->
<style>   
    .point {
      fill: #69b3a2;
      stroke: white;
      opacity: 0.3;
    }

    .selected {
      fill: #afa2dc;
      stroke: #2f225d;
      opacity: 1;
    }

    .axis {
      font: 10px sans-serif;
    }

    p {
      font: 12px sans-serif;
      margin: 0 0 2px 0;
      padding: 0;
    }

    .clear-button {
      font: 14px sans-serif;
      cursor: pointer;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .brush .extent {
      stroke: #fff;
      fill-opacity: .125;
      shape-rendering: crispEdges;
    }
</style>

<div id="volcano_plot"></div>

<body>
<script src="d3.v3.js"></script>

<label for="dropdown">Select a Cell Type</label>
<select class="dropdown_class" name="dropdown" id="cell_type_selection">
    <option value="de_df_10th_1st3rd.csv">Natural Killer Cells</option>
    <option value="de_df_10th_2nd3rd.csv">B Cells</option>
    <option value="de_df_10th_3rd3rd.csv">T Cells</option>
</select>

<script>
    d3v3.helper = {};

    // Begin Function Definitions
    // TODO: Move function defs into their own file
    d3v3.helper.tooltip = function(){
        var tooltipDiv;
        var bodyNode = d3v3.select('body').node();

        function tooltip(selection){

            selection.on('mouseover.tooltip', function(pD, pI){
                // Clean up lost tooltips
                d3v3.select('body').selectAll('div.tooltip').remove();
                // Append tooltip
                tooltipDiv = d3v3.select('body')
                               .append('div')
                               .attr('class', 'tooltip')
                var absoluteMousePos = d3v3.mouse(bodyNode);
                tooltipDiv.style({
                    left: (absoluteMousePos[0] + 10)+'px',
                    top: (absoluteMousePos[1] - 40)+'px',
                    'background-color': 'white',
                    border: 'solid',
                    'border-width': "2px",
                    'border-radius': '5px',
                    padding: '5px',
                    padding: '5px',
                    position: 'absolute',
                    'z-index': 1001,
                    'box-shadow': '0 1px 2px 0 #656565'
                });

                var only_line = '<p>Gene: ' + pD.gene_name + '</p>'
                tooltipDiv.html(only_line)
            })
            .on('mousemove.tooltip', function(pD, pI){
                // Move tooltip
                var absoluteMousePos = d3v3.mouse(bodyNode);
                tooltipDiv.style({
                    left: (absoluteMousePos[0] + 20)+'px',
                    top: (absoluteMousePos[1] - 30)+'px'
                });
            })
            .on('mouseout.tooltip', function(pD, pI){
                // Remove tooltip
                tooltipDiv.remove();
            });

        }

        tooltip.attr = function(_x){
            if (!arguments.length) return attrs;
            attrs = _x;
            return this;
        };

        tooltip.style = function(_x){
            if (!arguments.length) return styles;
            styles = _x;
            return this;
        };

        return tooltip;
    };

    function readCSVFile(filePath) {
      const request = new XMLHttpRequest();
      request.open("GET", filePath, false);
      request.send();
      const csvData = request.responseText;
      const rows = csvData.split("\n");
      const headerRow = rows[0].split(",");
      const dataRows = rows.slice(1);
      const result = [];
      for (let i = 0; i < dataRows.length; i++) {
        const dataRow = dataRows[i].split(",");
        const obj = {};
        for (let j = 0; j < headerRow.length; j++) {
          obj[headerRow[j]] = dataRow[j];
        }
        result.push(obj);
      }
      return result;
    }

    function transition_data() {
      svg.selectAll(".point")
      .data(data)
      .transition()
      .duration(500)
      .attr("cx", function(d) { return x(d.log2FoldChange); })
      .attr("cy", function(d) { return y(d.stat); });
    }

    function reset_axis() {
      svg.transition().duration(500)
       .select(".x.axis")
       .call(xAxis)

      svg.transition().duration(500)
       .select(".y.axis")
       .call(yAxis)
    }

    var idleTimeout
    function idled() { idleTimeout = null; }   

    function brushend() {
      var extent = brush.extent()
      console.log(extent)

      if(extent[0][0] == extent[1][0] || extent[0][1] == extent[1][1]) {
        // Another way to write the conditional below
        // if (!idleTimeout) return idleTimeout = setTimeout(idled, 350);
        if (!idleTimeout) {
            idleTimeout = setTimeout(idled, 350);
            return
        }
        x.domain([minh, maxh])
        y.domain([minv, maxv])
      } else {
        x.domain([extent[0][0], extent[1][0]])
        y.domain([extent[0][1], extent[1][1]])
        points.classed("selected", false);
        d3v3.select(".brush").call(brush.clear());
      }

      transition_data();
      reset_axis();  
    }

    function brushmove() {
      var extent = brush.extent();
      points.classed("selected", function(d) {
        //console.log(extent)
        var h_brushed = extent[0][0] <= d.log2FoldChange && d.log2FoldChange <= extent[1][0]
        var v_brushed = extent[0][1] <= d.stat && d.stat <= extent[1][1]
        return h_brushed && v_brushed;
      });
    }

    function update(event) {
        var data = readCSVFile(event.target.value)

        // Find ranges for axes
        // Horizontal
        const hvals = data.map((row) => parseFloat(row.log2FoldChange));
        const numeric_hvals = hvals.filter((val) => !Number.isNaN(val));
        const minh = Math.min(...numeric_hvals);
        const maxh = Math.max(...numeric_hvals);

        // Vertical
        const vvals = data.map((row) => parseFloat(row.stat));
        const numeric_vvals = vvals.filter((val) => !Number.isNaN(val));
        const minv = Math.min(...numeric_vvals)
        const maxv = Math.max(...numeric_vvals)

        x.domain([minh, maxh])
        y.domain([minv, maxv]) 

        svg.selectAll(".point").remove()

        points = svg.selectAll(".point")
            .data(data)
            .enter()
            .append("circle")
            .attr("class", "point")
            .attr("clip-path", "url(#clip)")
            .attr("r", 8)
            .attr("cx", function(d) { return x(d.log2FoldChange); })
            .attr("cy", function(d) { return y(d.stat); })
            .call(d3v3.helper.tooltip());

        /*
        points.on('mousedown', function(){
          brush_elm = svg.select(".brush").node();
          new_click_event = new Event('mousedown');
          new_click_event.pageX = d3v3.event.pageX;
          new_click_event.clientX = d3v3.event.clientX;
          new_click_event.pageY = d3v3.event.pageY;
          new_click_event.clientY = d3v3.event.clientY;
          brush_elm.dispatchEvent(new_click_event);
        });
        */
        
        transition_data();
        reset_axis();  

        console.log(event.target.value)
    }

    function create_axis_labels(svg, width, height) {
        let v_axis_label_adjust = -40
        let h_axis_label_adjust = 30
        let font_family = 'Arial'

        // Horizontal axis label
        svg.append("text")
            .attr("class", "x label left")
            .attr("text-anchor", "end")
            .attr("x", width)
            .attr("y", height + h_axis_label_adjust)
            .text("More Expression")
            .attr('font-size', '10px')
            .attr('font-family', font_family)

        svg.append("text")
            .attr('class', 'x label right')
            .attr('text-anchor', 'Begin')
            .attr('x', 0)
            .attr('y', height + h_axis_label_adjust)
            .text('Less Expression')
            .attr('font-size', '10px')
            .attr('font-family', font_family)    

        // Vertical axis label
        svg.append("text")
            .attr("class", "y label")
            .attr("text-anchor", "middle")
            .attr("y", v_axis_label_adjust)
            .attr("x", -(height / 2))
            .attr("dy", ".75em")
            .attr("transform", "rotate(-90)")
            .text("Signal Strength")
            .attr("font-size","10px")
            .attr('font-family', "Arial")
    }

    // End Function Definitions 

    // Hereafter, js is essentially main()

    /* Begin canvas setup */
    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 40, left: 60},
        width = 460 - margin.left - margin.right,
        height = 450 - margin.top - margin.bottom;

    // Create the SVG
    var svg = d3v3.select("#volcano_plot").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Create axis labels
    create_axis_labels(svg, width, height)
    /* End canvas setup */

    svg.append("defs").append("clipPath")
        .attr("id", "clip")
      .append("rect")
        .attr("width", width)
        .attr("height", height);

    /* Hereafter, things depend on data */
    var data = readCSVFile("de_df_10th.csv");

    // Data prep: we wish only to use |stat|
    data.magstat = data.map((row) => Math.abs(parseFloat(row.stat)))
    console.log(data);

    /* Begin Setup axes and brush */
    // Find ranges for axes
    // Horizontal
    const hvals = data.map((row) => parseFloat(row.log2FoldChange));
    const numeric_hvals = hvals.filter((val) => !Number.isNaN(val));
    const minh = Math.min(...numeric_hvals);
    const maxh = Math.max(...numeric_hvals);

    // Vertical
    const vvals = data.map((row) => Math.abs(parseFloat(row.stat)));
    const numeric_vvals = vvals.filter((val) => !Number.isNaN(val));
    const minv = Math.min(...numeric_vvals)
    const maxv = Math.max(...numeric_vvals)

    var x = d3v3.scale.linear()
        .domain([minh, maxh])
        .range([ 0, width ]);

    var y = d3v3.scale.linear()
        .domain([minv, maxv])
        .range([ height, 0]);

    var brush = d3v3.svg.brush()
        .x(x)
        .y(y)
        .on("brush", brushmove)
        .on("brushend", brushend);

    var xAxis = d3v3.svg.axis()
        .scale(x)
        .orient("bottom");

    var yAxis = d3v3.svg.axis()
        .scale(y)
        .orient("left")
        .ticks(11);

    svg.append("g")
        .attr("class", "x axis")
        .attr("clip-path", "url(#clip)")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);

    svg.append("g")
        .attr("class", "brush")
        .call(brush)
      .selectAll('rect')
        .attr('height', height);
    /* End setup axes and brush */


    /*---------- begin points object region --------*/

    points = svg.selectAll(".point")
        .data(data)
        .enter().append("circle")
        .attr("class", "point")
        .attr("clip-path", "url(#clip)")
        .attr("r", 8)
        .attr("cx", function(d) { return x(d.log2FoldChange); })
        .attr("cy", function(d) { return y(Math.abs(d.stat)); })
        .call(d3v3.helper.tooltip());

    points.on('mousedown', function(){
      brush_elm = svg.select(".brush").node();
      new_click_event = new Event('mousedown');
      new_click_event.pageX = d3v3.event.pageX;
      new_click_event.clientX = d3v3.event.clientX;
      new_click_event.pageY = d3v3.event.pageY;
      new_click_event.clientY = d3v3.event.clientY;
      brush_elm.dispatchEvent(new_click_event);
    });

    // TODO: Make update take either a string or an event, and use only it to create points
    const selector = document.querySelector('.dropdown_class')
    selector.addEventListener("change", update)
</script>