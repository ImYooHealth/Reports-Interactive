<!DOCTYPE html>
<meta charset="utf-8">
<style>   
    .point {
      fill: #69b3a2;
      stroke: white;
      opacity: 0.3;
    }

    .selected {
      fill: #afa2dc;
      stroke: #2f225d;
      opacity: 1;
    }

    .axis {
      font: 10px sans-serif;
    }

    p {
      font: 12px sans-serif;
      margin: 0 0 2px 0;
      padding: 0;
    }

    .clear-button {
      font: 14px sans-serif;
      cursor: pointer;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .brush .extent {
      stroke: #fff;
      fill-opacity: .125;
      shape-rendering: crispEdges;
    }
</style>

<body>
<script src="d3.v3.min.js"></script>
<script>
d3.helper = {};

d3.helper.tooltip = function(){
    var tooltipDiv;
    var bodyNode = d3.select('body').node();

    function tooltip(selection){

        selection.on('mouseover.tooltip', function(pD, pI){
            // Clean up lost tooltips
            d3.select('body').selectAll('div.tooltip').remove();
            // Append tooltip
            tooltipDiv = d3.select('body')
                           .append('div')
                           .attr('class', 'tooltip')
            var absoluteMousePos = d3.mouse(bodyNode);
            tooltipDiv.style({
                left: (absoluteMousePos[0] + 10)+'px',
                top: (absoluteMousePos[1] - 40)+'px',
                'background-color': 'white',
                border: 'solid',
                'border-width': "2px",
                'border-radius': '5px',
                padding: '5px',
                padding: '5px',
                position: 'absolute',
                'z-index': 1001,
                'box-shadow': '0 1px 2px 0 #656565'
            });

            var only_line = '<p>Gene: ' + pD.gene_name + '</p>'
            tooltipDiv.html(only_line)
        })
        .on('mousemove.tooltip', function(pD, pI){
            // Move tooltip
            var absoluteMousePos = d3.mouse(bodyNode);
            tooltipDiv.style({
                left: (absoluteMousePos[0] + 20)+'px',
                top: (absoluteMousePos[1] - 30)+'px'
            });
        })
        .on('mouseout.tooltip', function(pD, pI){
            // Remove tooltip
            tooltipDiv.remove();
        });

    }

    tooltip.attr = function(_x){
        if (!arguments.length) return attrs;
        attrs = _x;
        return this;
    };

    tooltip.style = function(_x){
        if (!arguments.length) return styles;
        styles = _x;
        return this;
    };

    return tooltip;
};

function readCSVFile(filePath) {
  const request = new XMLHttpRequest();
  request.open("GET", filePath, false);
  request.send();
  const csvData = request.responseText;
  const rows = csvData.split("\n");
  const headerRow = rows[0].split(",");
  const dataRows = rows.slice(1);
  const result = [];
  for (let i = 0; i < dataRows.length; i++) {
    const dataRow = dataRows[i].split(",");
    const obj = {};
    for (let j = 0; j < headerRow.length; j++) {
      obj[headerRow[j]] = dataRow[j];
    }
    result.push(obj);
  }
  return result;
}

var data = readCSVFile("de_df_10th.csv");
console.log(data);

// Find ranges for axes
// Horizontal
const hvals = data.map((row) => parseFloat(row.log2FoldChange));
const numeric_hvals = hvals.filter((val) => !Number.isNaN(val));
const minh = Math.min(...numeric_hvals);
const maxh = Math.max(...numeric_hvals);

// Vertical
const vvals = data.map((row) => parseFloat(row.stat));
const numeric_vvals = vvals.filter((val) => !Number.isNaN(val));
const minv = Math.min(...numeric_vvals)
const maxv = Math.max(...numeric_vvals)

// set the dimensions and margins of the graph
var margin = {top: 10, right: 30, bottom: 30, left: 60},
    width = 460 - margin.left - margin.right,
    height = 450 - margin.top - margin.bottom;

var x = d3.scale.linear()
    .domain([minh, maxh])
    .range([ 0, width ]);

var y = d3.scale.linear()
    .domain([minv, maxv])
    .range([ height, 0]);

var brush = d3.svg.brush()
    .x(x)
    .y(y)
    .on("brush", brushmove)
    .on("brushend", brushend);

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .ticks(11);

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

svg.append("g")
    .attr("class", "x axis")
    .attr("clip-path", "url(#clip)")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);

svg.append("g")
    .attr("class", "y axis")
    .call(yAxis);

svg.append("g")
    .attr("class", "brush")
    .call(brush)
  .selectAll('rect')
    .attr('height', height);

svg.append("defs").append("clipPath")
    .attr("id", "clip")
  .append("rect")
    .attr("width", width)
    .attr("height", height);

points = svg.selectAll(".point")
    .data(data)
    .enter().append("circle")
    .attr("class", "point")
    .attr("clip-path", "url(#clip)")
    .attr("r", 8)
    .attr("cx", function(d) { return x(d.log2FoldChange); })
    .attr("cy", function(d) { return y(d.stat); })
    .call(d3.helper.tooltip());

points.on('mousedown', function(){
  brush_elm = svg.select(".brush").node();
  new_click_event = new Event('mousedown');
  new_click_event.pageX = d3.event.pageX;
  new_click_event.clientX = d3.event.clientX;
  new_click_event.pageY = d3.event.pageY;
  new_click_event.clientY = d3.event.clientY;
  brush_elm.dispatchEvent(new_click_event);
});

function brushmove() {
  var extent = brush.extent();
  points.classed("selected", function(d) {
    //console.log(extent)
    var h_brushed = extent[0][0] <= d.log2FoldChange && d.log2FoldChange <= extent[1][0]
    var v_brushed = extent[0][1] <= d.stat && d.stat <= extent[1][1]
    return h_brushed && v_brushed;
  });
}

var idleTimeout
function idled() { idleTimeout = null; }

function brushend() {
  var extent = brush.extent()
  console.log(extent)

  if(extent[0][0] == extent[1][0] || extent[0][1] == extent[1][1]) {
    // Another way to write the conditional below
    // if (!idleTimeout) return idleTimeout = setTimeout(idled, 350);
    if (!idleTimeout) {
        idleTimeout = setTimeout(idled, 350);
        return
    }
    x.domain([minh, maxh])
    y.domain([minv, maxv])
  } else {
    x.domain([extent[0][0], extent[1][0]])
    y.domain([extent[0][1], extent[1][1]])
    points.classed("selected", false);
    d3.select(".brush").call(brush.clear());
  }

  transition_data();
  reset_axis();  
}

function transition_data() {
  svg.selectAll(".point")
  .data(data)
  .transition()
  .duration(500)
  .attr("cx", function(d) { return x(d.log2FoldChange); })
  .attr("cy", function(d) { return y(d.stat); });
}

function reset_axis() {
  svg.transition().duration(500)
   .select(".x.axis")
   .call(xAxis)

  svg.transition().duration(500)
   .select(".y.axis")
   .call(yAxis)
}
</script>