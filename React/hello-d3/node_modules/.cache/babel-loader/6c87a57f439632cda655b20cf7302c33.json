{"ast":null,"code":"import { range } from \"d3-array\";\nimport { max, tau } from \"./math\";\nfunction compareValue(compare) {\n  return function (a, b) {\n    return compare(a.source.value + a.target.value, b.source.value + b.target.value);\n  };\n}\nexport default function () {\n  var padAngle = 0,\n    sortGroups = null,\n    sortSubgroups = null,\n    sortChords = null;\n  function chord(matrix) {\n    var n = matrix.length,\n      groupSums = [],\n      groupIndex = range(n),\n      subgroupIndex = [],\n      chords = [],\n      groups = chords.groups = new Array(n),\n      subgroups = new Array(n * n),\n      k,\n      x,\n      x0,\n      dx,\n      i,\n      j;\n\n    // Compute the sum.\n    k = 0, i = -1;\n    while (++i < n) {\n      x = 0, j = -1;\n      while (++j < n) {\n        x += matrix[i][j];\n      }\n      groupSums.push(x);\n      subgroupIndex.push(range(n));\n      k += x;\n    }\n\n    // Sort groups…\n    if (sortGroups) groupIndex.sort(function (a, b) {\n      return sortGroups(groupSums[a], groupSums[b]);\n    });\n\n    // Sort subgroups…\n    if (sortSubgroups) subgroupIndex.forEach(function (d, i) {\n      d.sort(function (a, b) {\n        return sortSubgroups(matrix[i][a], matrix[i][b]);\n      });\n    });\n\n    // Convert the sum to scaling factor for [0, 2pi].\n    // TODO Allow start and end angle to be specified?\n    // TODO Allow padding to be specified as percentage?\n    k = max(0, tau - padAngle * n) / k;\n    dx = k ? padAngle : tau / n;\n\n    // Compute the start and end angle for each group and subgroup.\n    // Note: Opera has a bug reordering object literal properties!\n    x = 0, i = -1;\n    while (++i < n) {\n      x0 = x, j = -1;\n      while (++j < n) {\n        var di = groupIndex[i],\n          dj = subgroupIndex[di][j],\n          v = matrix[di][dj],\n          a0 = x,\n          a1 = x += v * k;\n        subgroups[dj * n + di] = {\n          index: di,\n          subindex: dj,\n          startAngle: a0,\n          endAngle: a1,\n          value: v\n        };\n      }\n      groups[di] = {\n        index: di,\n        startAngle: x0,\n        endAngle: x,\n        value: groupSums[di]\n      };\n      x += dx;\n    }\n\n    // Generate chords for each (non-empty) subgroup-subgroup link.\n    i = -1;\n    while (++i < n) {\n      j = i - 1;\n      while (++j < n) {\n        var source = subgroups[j * n + i],\n          target = subgroups[i * n + j];\n        if (source.value || target.value) {\n          chords.push(source.value < target.value ? {\n            source: target,\n            target: source\n          } : {\n            source: source,\n            target: target\n          });\n        }\n      }\n    }\n    return sortChords ? chords.sort(sortChords) : chords;\n  }\n  chord.padAngle = function (_) {\n    return arguments.length ? (padAngle = max(0, _), chord) : padAngle;\n  };\n  chord.sortGroups = function (_) {\n    return arguments.length ? (sortGroups = _, chord) : sortGroups;\n  };\n  chord.sortSubgroups = function (_) {\n    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;\n  };\n  chord.sortChords = function (_) {\n    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;\n  };\n  return chord;\n}","map":null,"metadata":{},"sourceType":"module"}